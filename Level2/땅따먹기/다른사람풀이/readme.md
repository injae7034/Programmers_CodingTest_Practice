# 다른 사람이 풀이한 코드
```java
class Solution {
    public int solution(int n) {
        int answer[] = new int[n+1];
        answer[0] = 0;
        answer[1] = 1;
        for (int i = 2; i <= n; i++)
        {
            int sum = answer[i-2] + answer[i-1];
            answer[i] = sum % 1234567;
        }
        return answer[n];
    }
}
}
```

# 다른 사람이 풀이한 코드 해석하며 공부하기

answer배열을 만들어주는데 크기는 n+1로 설정합니다.<br><br>
그 이유는 배열은 0부터 시작하기때문에 n번째 배열요소가 있으려면 크기를 n+1로 설정해야 합니다.<br><br>
그리고 배열을 만드는 이유는 피보나치수는 일정하게 정해져 있어서 중복이 발생하는데<br><br>
이를 매번 구하면 효율성이 떨어지기 때문에 계속해서 나타나는 수들을 배열을 통해 저장하고,<br><br>
이를 꺼내서 활용하면 효율성을 올릴 수 있습니다.<br><br>
answer의 i번째 배열요소에는 i번째 피보나치수를 1234567로 나눈 나머지를 저장할 것입니다.<br><br>
일단 answer의 0번째 원소는 0인데 피보나치 0번째수는 0이기 때문에 1234567로 나눠도 0입니다.<br><br>
1번째 원소는 1인데 피보나치 1번째수는 1이기 때문에 1234567로 나눠도 1입니다.<br><br>
이렇게 answer배열의 0번째원소와 1번째 원소의 값을 미리 넣어두는 이유는<br><br>
예를 들어 아래 코드처럼<br><br>
```java
 for (int i = 0; i <= n; i++)
 {
     if (i == 0) answer[i] = 0;
     else if (i == 1) answer[i] = 1;
     else 
     {
          int sum = answer[i-2] + answer[i-1];
          answer[i] = sum % 1234567;
     }
}
```
반복문에서 선택문으로 i = 0과 i = 1이면 이값을 넣으면 단 한번을 위해<br><br>
매번 반복문에서 선택구조로 i가 0과 1과 같은지 확인을 해야하기 때문에 굉장히 비효율적입니다.<br><br>
차라리 i = 0과 i = 1은 한번이기 때문에 반복문 밖에서 처리해주고 반복문 내부에서 선택문을 없애는 것이 훨씬 더 효율적입니다.<br><br>
다시 돌아가서 i = 2부터 n보다 작거나 같은 동안 반복합니다.<br><br>
i = 2인경우 sum에는 answer의 0번째와 1번째 원소의 합이 저장되는데 그 값이 1입니다.<br><br>
이를 1234567로 나눈 나머지 1을 answer의 2번째 원소에 저장합니다.<br><br>
이렇게 반복이 끝나고 나면 answer의 n번째 배열요소에는 n번째 피보나치수를 1234567로 나눈 나머지를 저장될 것입니다.<br><br>
이를 반환하면 정답입니다.<br><br>
n-2번째 피보나치수를 1234567로 나눈 나머지와 n-1번째 피보나치수를 1234567로 나눈 나머지의 합이 n번째 피보나치수를 1234567로 나눈 나머지와 같은 이유는<br><br>
**모듈러 연산의 성질**때문입니다.<br><br>
숫자 A, B, C가 있다고 하면 (A + B) % C의 값은 ((A % C) + (B % C)) % C와 같은 것이 모듈려 연산의 성질입니다.<br><br>
-에도 적용되어 (A - B) % C의 값은 ((A % C) - (B % C)) % C와 같고,<br><br>
\*에도 적용되어 (A \* B) % C의 값은 ((A % C) \* (B % C)) % C와 같습니다.<br><br>
즉, 이 성질을 활용하여 answer에는 미리 1234567로 나눈 나머지들을 저장하고,<br><br>
그 값으로 더하면 n번째 피보나치수를 1234567로 나눈 나머지와 같은 결과가 나옵니다.

# 느낀 점
피보나치수열의 경우 재귀로 하면 굉장히 비효율적이라 일단 반복을 하는 것이 훨씬 낫습니다.<br><br>
또한 피보나치수열의 경우 중복해서 구하는 값이 많기 때문에 이를 줄이기 위해 배열을 활용해 값을 저장하고<br><br>
필요할 때마다 가져오는 것이 효율성 면에서 훨씬 좋습니다.<br><br>
또한 모듈러 연산을 통해서 피보나치수 n번째를 1234567로 나눈 나머지의 값이<br><br>
n -2 번째를 1234567로 나눈 나머지와 n -1번째를 1234567로 나눈 나머지의 합을 1234567로 나눈 나머지와 같다는 것을 알 수 있었고<br><br>
이를 활용해 피보나치 수처럼 기하급수적으로 숫자가 커질 경우 숫자범위를 넘지 않게 효율적으로 계산할 수 있습니다.
