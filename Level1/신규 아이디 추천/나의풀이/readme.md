# 내가 푼 코드
```java
package ProgramersLevel01;

class Solution {
    public String solution(String new_id) {
        String answer = "";
        //1단계
        answer = new_id.toLowerCase();
        //2단계
        String[] answers = answer.split("\\~|\\!|\\@|\\#|\\$|\\%|\\^|\\&" +
                "|\\*|\\(|\\)|\\=|\\+|\\[|\\]|\\{|\\}|\\:|\\?|,|\\<|\\>|\\/");
        answer = "";
        for(String str : answers)
        {
            answer += str;
        }
        //3단계
        while(answer.indexOf("..") != -1)
        {
            answer = answer.replace("..", ".");
        }
        //4단계
        if(answer.length() > 0 && answer.charAt(0) == '.')
        {
            answer = answer.replaceFirst(".", "");
        }
        if(answer.length() > 0 && answer.charAt(answer.length() - 1) == '.')
        {
            answer = answer.substring(0, answer.length() - 1);
        }
        //5단계
        if(answer.compareTo("") == 0)
        {
            answer = "a";
        }
        //6단계
        if(answer.length() > 15)
        {
            answer = answer.substring(0, 15);
            if(answer.charAt(answer.length() - 1) == '.')
            {
                answer = answer.substring(0, answer.length() - 1);
            }
        }
        //7단계
        while(answer.length() <= 2)
        {
            answer += answer.charAt(answer.length() -1);
        }
        return answer;
    }
}
```

# 내가 푼 코드 설명

1단계는 매개변수로 입력 받은 문자열인 new_id에서 모든 대문자를 소문자로 치환시키는 단계입니다.<br><br>
이를 위해 String클래스의 toLowerCase메소드를 이용해 모든 대문자를 소문자로 치환시킵니다.<br><br>
2단계는 알파벳 소문자, 숫자, 빼기(-), 밑줄(\_), 마침표(\.)를 제외한 모든 문자를 제거하는 단계입니다.<br><br>
new_id에 나타날 수 있는 특수문자는 \-\_\.\~\!\@\#\$\%\^\&\*\(\)\=\+\[\{\]\}\:\?\,\<\>\/로 한정되어 있다고 문제에서 제시하고 있습니다.<br><br>
그래서 **String의 split메소드를 활용**합니다.<br><br>
split메소드에 **매개변수로 \~\!\@\#\$\%\^\&\*\(\)\=\+\[\{\]\}\:\?\,\<\>\/을 입력**하여 이를 기준으로 **문자열을 분리**하도록 하고,<br><br>
이 **반환값을 String 배열에 저장**합니다.<br><br>
이 때 주의할 점이 매개변수로 특수문자를 입력할 때 특수문자 앞에 "\\\\"를 입력하여 특수문자를 인식할  수 있도록 처리를 해줘야 한다는 점입니다.<br><br>
"\\\\"이 없으면 특수문자를 인식하지 못하기 때문에 에러가 발생합니다.<br><br>
반환값인 **String배열에는 split에서 매개변수로 입력 받은 특수문자는 제거되어 있을 것**이고, 이를 기준으로 **분리된 문자열들이 저장**되어 있을 겁니다.<br><br>
문자열 참조변수인 answer를 공백으로 초기화시킨 다음에<br><br>
split에서 반환받은 문자열 배열을 처음부터 마지막까지 각 배열요소를 하나씩 순차적으로 answer에 **+연산을 시켜 누적**시켜줍니다.<br><br>
반복문이 끝나고나면 answer에는 위의 **특수문자가 제거된 하나의 문자열이 저장**될 것입니다.<br><br>
3단계는 마침표(\.)가 2번 이상 연속된 부분을 하나의 마침표(\.)로 치환하는 과정입니다.<br><br>
String의 replace 메소드를 이용해 매개변수로 바꿔야 하는 대상인 "\.\."과 바꾸기로 원하는 값인 "\."을 전달합니다.<br><br>
그러면 answer에 있는 모든 ".\.\" 마침표가 2개인 문자열이 마침표가 1개인 문자열로 치환됩니다.<br><br>
그러나 여기서 **주의할 점**이 하나 있는데 저도 이것 때문에 처음에 애를 먹었는데,<br><br>
바로 **\.\.\. 이렇게 마침표가 3개 또는 그 이상의 개수가 연속으로 있는 경우**가 문제가 됩니다.<br><br>
String의 replace를 통해 바꾸는 과정에서 예를 들어, 마침표가 연속으로 3개가 있으면 앞의 마침표 2개를 1개의 마침표로 바꾸고,<br><br>
다음 문자열의 원소 위치로 넘어가는데 마침표가 1개가 있기 때문에 문제가 없다고 인식하여 그냥 넘어갑니다.<br><br>
그러나 실상은 **앞에서 2개의 마침표를 하나로 바꾸고, 다음에 1개의 마침표가 바로 존재하기 때문에 2개의 마침표가 존재**하게 됩니다.<br><br>
마침표가 연속해서 4개나 5개 그 이상일 경우도 마찬가지입니다.<br><br>
이러한 문제가 생기는 이유는 replace를 한번 호출하면 일회성이기 때문에<br><br>
replace 한번 호출로 마침표가 2개인 것을 모두 바꿨지만<br><br>
바꾸는 과정에서 3개이상 연속으로 있는 마침표는 1회의 replace로 처리할 수 없기 때문입니다.<br><br>
그래서 이러한 문제를 해결하기 위해 반복문을 이용합니다.<br><br>
여기서 반복조건을 어떻게 설정하느냐가 관건입니다.<br><br>
반복조건으로는 String클래스의 메소드인 indexOf에 매개변수로 마침표 2개를 전달합니다.<br><br>
찾으면 해당 문자열의 시작위치가 반환되고, 찾지 못하면 -1이 반환됩니다.<br><br>
그래서 이 반환값이 -1이 아닌 동안 즉, 마침표가 연속으로 2개가 있는 동안은 계속 반복하면서 replace를 호출하여 마침표 2개 이상을 1개로 바꿔줍니다.<br><br>
아까의 예시에 적용해보면 마침표 3개가 연속으로 있는 경우 당연히 indexOf의 반환값은 -1이 아닐 것이기 때문에 최초에는 반복문으로 들어갑니다.<br><br>
그리고 replace메소드를 이후에는 연속 3개의 마침표가 있는 마침표가 2개로 바뀔 것입니다.<br><br>
이 후 다시 반복조건문을 통해 indexOf에서 마침표 2개를 찾으면 찾은 결과가 있을 것이기 때문에 다시 반복구조로 들어가서 마침표 2개를 마침표 1개로 바꿔줍니다.<br><br>
다시 반복문으로 가면 이제 마침표가 2개이상 연속으로 있는 경우가 없기 때문에 indexOf에서 -1이 반환될 것이고,<br><br>
이를 통해 answer에서 마침표가 연속해서 2개이상 있는 경우를 모두 마침표 1개로 바꿔줄 수 있습니다.<br><br>
4단계는 new_id에서 마침표(\.)가 처음이나 끝에 위치한다면 제거하는 단계인데, String클래스의 charAt메소드를 이용합니다.<br><br>
charAt(0)을 호출하면 answer문자열에서 제일 처음에 위치한 문자를 반환하고,<br><br>
charAt(answer.length() - 1)을 하면 answer문자열에서 제일 마지막에 위치한 문자를 반환합니다.<br><br>
이 문자를 \=\=를 통해 마침표와 같은지 비교를 하는데 같으면 제거해주는 처리를 합니다.<br><br>
이 때 주의할 점이 있는데, charAt을 하기 위해서는 적어도 answer문자열에 문자가 1개 이상은 있어야 합니다.<br><br>
즉, answer문자열이 공백이 아니라는 가정하에서 charAt을 통해 처음과 마지막의 문자를 확인해야 합니다.<br><br>
그래서 먼저 answer문자열이 0보다 크면, 즉, answer문자열에 문자가 최소 1개이상이 있으면 charAt을 통해 확인하는 과정을 거치도록 해줍니다.<br><br>
그래서 선택구조에서 먼저 length가 0보다 큰지 그리고 charAt(0)이 마침표와 같은지를 확인합니다.<br><br>
그리고 마지막에 마침표가 있는지 확인하기 위해서도 별도로 length먼저 0보다 큰지 구하고, charAt(length -1)을 통해 마지막 문자가 마침표와 같은지 확인합니다.<br><br>
처음에 마침표가 있다면 replaceFirst메소드를 통해 마침표를 공백으로 바꿔주면 성공적으로 처음에 마침표를 제거해줄 수 있습니다.<br><br>
replace는 문자열 전체에서 입력한 문자열을 원하는 문자열로 바꿔주지만<br><br>
replaceFirst는 입력한 문자열에서 처음 발견되는 문자열만 원하는 문자열로 바꿔주고, 나머지는 바꿔주지 않습니다.<br><br>
마지막 문자열에 마침표가 있다면 이는 substring메소드에 문자열의 처음위치와 마지막 문자열 위치를 넣어주면<br><br>
마지막 문자열 전까지 문자를 반환하기 때문에 성공적으로 마지막 문자열의 마침표를 제거할 수 있습니다.<br><br>
5단계는 ew_id가 빈 문자열이라면, new_id에 "a"를 대입하는 과정입니다.<br><br>
String클래스의 compareTo메소드를 이용해 ""과 answer과 같으면 answer에 "a"를 대입해줍니다.<br><br>
6단계는 new_id의 길이가 16자 이상이면, new_id의 첫 15개의 문자를 제외한 나머지 문자들을 모두 제거하는 단계입니다.<br><br>
이 때 만약 제거 후 마침표(\.)가 new_id의 끝에 위치한다면 끝에 위치한 마침표(\.) 문자를 제거해 줘야 합니다.<br><br>
먼저 선택구조로 answer문자열이 15보다 큰지 물어보고 15보다 크다면 substring(0, 15)를 호출하여 뒤의 문자열들을 제거해줍니다.<br><br>
문자열을 제거한 후에 마지막 문자가 마침표와 같은지 charAt을 통해 확인하고,<br><br>
마침표라면 substring(0, answer.length() - 1)을 통해 다시 마지막 문자인 마침표를 제거해줍니다.<br><br>
7단계는 new_id의 길이가 2자 이하라면, new_id의 마지막 문자를 new_id의 길이가 3이 될 때까지 반복해서 끝에 붙이는 과정입니다.<br><br>
while반복문의 조건으로 answer의 length가 2보다 작거나 같은 동안 반복을 합니다.<br><br>
반복문 내부에서는 +연산으로 answer 자신에게 자신의 마지막 문자를 더해서 누적시키는 과정을 처리해줍니다.<br><br>
덧셈 연산 후에 개수가 변동이 있을 것인데 아직 2보다 작거나 같으면 다시 반복을 할 것이고 개수가 3이 되면 반복문을 빠져 나올 것입니다.<br><br>
이 모든 과정을 거치면 answer에는 원하는 결과가 저장되어 있을 것이고 이를 반환합니다.
