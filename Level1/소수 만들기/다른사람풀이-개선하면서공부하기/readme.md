# 다른 사람이 푼 코드 중 개선한 코드

```java
class Solution 
{
    public int solution(int[] nums) 
    {
        int answer = 0;
        for(int i = 0; i < nums.length - 2; i++)
        {
            for(int j = i + 1; j < nums.length - 1; j++)
            {
                for(int k = j + 1; k < nums.length; k++)
                {
                    if(isPrimeNumber(nums[i] + nums[j] + nums[k]) == true)
                    {
                        answer++;
                    }
                }
            }
        }
        return answer;
    }
    private boolean isPrimeNumber(int number)
    {
        for(int i=2; i*i <= number; i++)
        {
            if(number % i == 0)
            {
                return false;           
            }
        }
        return true;
    }
}
```

# 해석하며 공부하기

삼중반복을 통해 매개변수로 입력 받은 숫자배열에서 원소 하나씩 차례로 구한 다음 그 합을 구합니다.<br><br>
여기서 중요한 점은 **첫번째 반복**은 배열첨자위치 **i = 0부터 시작해서 nums.length - 2까지 반복**을 돌립니다.<br><br>
**두번째 반복**은 배열첨자위치가 **j = i + 1부터 시작해서 nums.length - 1까지 반복**을 돌립니다.<br><br>
**세번째 반복**은 배열첨자위치가 **k = j + 1부터 시작해서 nums.length까지 반복**을 돌립니다.<br><br>
이렇게 3중반복을 돌리면 매개변수로 입력 받은 숫자배열에서 3개 원소의 합의 모든 경우의 수를 다 구할 수 있습니다.<br><br>
이제 이 3개의 원소들의 합이 소수인지 아닌지를 판단하기 위해 isPrimeNumber메소드를 정의합니다.<br><br>
isPrimeNumber는 soultion메소드에서만 호출되기 때문에 접근제어자는 private으로 정하고, 매개변수는 3개 원소의 합이고<br><br>
반환값은 boolean입니다.<br><br>
매개변수로 입력 받은 숫자가 소수인지 아닌지 판단하기 위한 방법은 3가지가 있습니다.<br><br>
첫번째는 가장 간단한 방법으로 **i = 2부터 시작해서 매개변수로 입력 받은 숫자보다 작은 동안 반복**을 하면서<br><br>
반복문 내부에서 i로 나눠보고, 나머지가 0이면 소수가 아니고, 나머지가 0이면 소수로 정의한다.<br><br>
매개변수로 입력 받은 숫자전까지 모두 확인해야하므로 시간복잡도는 O(N)이 되고, 가장 원초적인 방법입니다.<br><br>
두번째는 **소수인지 판별하려는 숫자의 절반**까지만 확인하는 방법입니다.<br><br>
이 원리는 절반 이상의 숫자들은 확인이 필요 없는 숫자들이라는 점에서 착안한 방법입니다.<br><br>
예를 들어, 80이란 숫자에서 자기자신을 제외하고,<br><br>
80의 절반인 40을 초과하는 숫자에서 80을 나눴을 때는 나머지가 0이되는 숫자는 나올수가 없습니다.<br><br>
해당 풀이를 사용하면 최대 N/2번 조회를 합니다.<br><br>
시간복잡도에서 상수는 제외하므로 해당 풀이의 시간복잡도도 O(N)이 됩니다.<br><br>
세번째 방법이 제가 차용한 방법인데 가장 효율적인 방법입니다.<br><br>
**소수인지 판별하려는 숫자의 √N 까지 확인하는 방법**입니다.<br><br>
이 원리는 약수의 중심을 구하는 방법입니다.<br><br>
예를 들어, 80의 약수는 1, 2, 4, 5, 8, 10, 16, 20, 40, 80입니다.<br><br>
각 숫자들의 곱이 80이되는 쌍은 1:80, 2:40, 4:20, 5:16, 8:10 입니다.<br><br>
√80의 값은 대략 8.xxx의 값이 나옵니다.<br><br>
즉, 약수들의 곱으로 봤을 때 소수인지 판별하려는 수 80을 루트로 씌운 값이 중간 값이 됩니다.<br><br>
이 원리는 이용하여 2에서부터 √N의 값까지 검색을 한다면 이후의 값은 확인할 필요가 없게 되고<br><br>
시간복잡도는 O(√N)이 됩니다.<br><br>
코드의 가독성을 위해 루트함수는 사용하지 않고 i의 제곱값으로 표현합니다.<br><br>
이 방법을 이용해 반복문 내부에서 나머지가 0인 결과가 나오면 소수가 아닌 false를 반환하고<br><br>
반복문이 끝나는 동안 나머지가 0이 계속 아니면 소수이므로 true를 반환합니다.<br><br>
이 반환 받은 값을 활용해 이 값이 true이면 answer의 값을 +1 증가시켜서 그 값을 누적시킵니다.<br><br>
이런식으로 3중반복을 돌리면서 숫자배열에서 3개의 원소의 합의 모든 경우의 수 중에 소수가 모두 몇 개인지를 구하고, 그 결과를 반환합니다.
